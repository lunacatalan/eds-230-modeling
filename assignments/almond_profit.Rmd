---
title: "Almond Yield Assignment"
authors: "Luna Hershenfeld-Catalan & Sofia Ingersoll"
date: "2024 April 12"
output:
  slidy_presentation:
    highlight: pygments
  html_document: default
  pdf_document: default
  ioslides_presentation:
    highlight: pygments
  beamer_presentation:
    highlight: pygments
---
# Instructions 
In your same groups - 

+ Develop a profit model for your almond yield (you can make this up - think about what the parameters would be)

      * you might assume a baseline profit and then adjust according to the anomaly  

     * there are many ways to combine the almond yield and profit functions; you can have the profit function "call"/use the almond yield function; or create a wrapper function that calls them in sequence (first the almond yield and then the profit function) 

+ Do a simple informal sensitivity analysis of almond yield profit using at least 2 parameters

+ Create 2 graphs of the results - you can decide what is the most meaningful graph 

* Write a short paragraph (in the Rmarkdown document) to summarize you interpretation of your model results (e.g what do 'take away' from your model and sensitivity analysis)

# Code

### Set up
```{r message = FALSE}
# chunk settings
knitr::opts_chunk$set(echo = TRUE#, message = FALSE, warning = FALSE
                      )
# libraries
library(tidyverse)
library(purrr)
library(here)

# load data
clim <- read.delim(here('assignments','clim.txt'),
                   header = TRUE,
                   sep = " ")
```

### Wrangle Monthly Data
```{r}
# Calculate monthly average minimum and maximum temperatures
monthly_clim <- clim %>%
  # this order was selected so we can easily access the previous month's total precip
  group_by(year, month) %>%
  summarize(min_tmin_c = min(tmin_c),
            total_precip = sum(precip)) %>% 
  # to assess almond yield profit overtime 
  filter(month == c(1, 2))

head(monthly_clim)
```

 # Almond Yield Function
```{r}
#' computes yield from min. monthly temp and last months total precip
#' @param  T_min (C)
#' @param  P (mm)
#' @param  year (yr)
#' @param  month (dy)
#' @return data frame with estimate of yield

almond_func <- function(df) {
  yields <- data.frame()
  
  # Filter the data to include only February rows
  feb_data <- df[df$month == 2, ]
  
  # Iterate over the February data
  for (i in 1:nrow(feb_data)) {
    year <- feb_data$year[i]
    t_min <- feb_data$min_tmin_c[i]
    
    # Get the January precipitation for the current year
    jan_precip <- df$total_precip[df$year == year & df$month == 1]
    
    # Calculate Y_min for February of the current year
      Y_min <- (-0.015 * t_min) - (0.0046 * (t_min^2)) - (0.07 * jan_precip) + (0.0043 * (jan_precip^2)) + 0.28
      
      # Create a dataframe with calculated values for the current year and month 2
      calculations <- data.frame(
        Year = rep(year, length(Y_min)),
        Month = rep(2, length(Y_min)),
        Y_min = Y_min
      )
      
      # Append the calculations to the yields dataframe
      yields <- rbind(yields, calculations)
  }
  
  # Calculate summary statistics for the yields
  yield_summary <- data.frame(
    Ymax = max(yields$Y_min, na.rm = TRUE),
    Ymin = min(yields$Y_min, na.rm = TRUE),
    Ymean = mean(yields$Y_min, na.rm = TRUE)
  )
  
  # Return both the summary statistics and the yields dataframe in a list
  return(list(yield_summary = yield_summary, yields = yields))
}
```
 
### Testing Updated Function
```{r}
almond_func(monthly_clim)
```
# Profit Yield Function

```{r}
#' computes profit from power generation
#' @param  price ($/kj)
#' @param  energy (kj/yr)
#' @param  year (when was energy obtained)
#' @param discount rate (default 0.12)
#' @return data frame with estimate of profit
compute_profit_frompower = function(energy, year, price, discount=0.12) {

  # make sure values are reasonable
  if (length(energy) < 1)
    return(NA)
  
  # energy cannot be negative
  if (min(energy ) < 0)
    return(NA)
  
  # generate a unique identifier or scenario number
  scen = seq(from=1, to=length(energy))
  yearprofit = data.frame(scen=scen, energy=energy, year=year)
  yearprofit$net =  yearprofit$energy*price

  # note how discount is passed through to this function
  # remember to normalize the year to start year e.g the first year
  yearprofit= yearprofit %>% 
      mutate(netpre = compute_NPV(value=net, time=year-year[1], discount=discount ))
  
  return(yearprofit)
}
```

# Net Present Value Function (NPV)
```{r}
#' compute_NPV
#' 
#' compute net present value
#' @param value/cost ($)
#' @param time in the future that cost/value occurs (years)
#' @param discount rate 
#' @return value in $


compute_NPV = function(value, time, discount=0.12) {
	result = value / (1 + discount)**time
	return(result)
}
```


# Sensitivty Analysis on 2 Parameters
**pulling from  `InformalSensitivity2.Rmd``**
### mapping parameters
```{r}
almond_func <- function(T, P, df) {
  yields <- data.frame()
  
  # iterate over the rows to get yields
  for(date in 1:nrow(df)) {
    T_min <- T[date]
    
    # Use the previous month's precipitation
    if (date > 1) {
      P_val <- P[date - 1]
    } else {
      P_val <- NA
    }
    
    # Calculate yield
    Y_min <- (-0.015 * T_min) - (0.0046 * (T_min^2)) - (0.07 * P_val) + (0.0043 * (P_val^2)) + 0.28
    
    # Print out intermediate values for debugging
    cat("T_min:", T_min, "\n")
    cat("P_val:", P_val, "\n")
    cat("Y_min:", Y_min, "\n")
    
    # Get the year and month for the current row
    Year <- df$year[date]
    Month <- df$month[date]
    
    # Create a dataframe with yield, year, and month
    calculations <- data.frame(
      Year = Year,
      Month = Month,
      Y_min = Y_min
    )
    
    # Append the calculations to the yields dataframe
    yields <- rbind(yields, calculations)
  }
  
  # Remove rows with NA values in Y_min
  yields <- na.omit(yields)
  
  # Calculate summary statistics for the yields
  yield_summary <- data.frame(
    Ymax = max(yields$Y_min, na.rm = TRUE),
    Ymin = min(yields$Y_min, na.rm = TRUE),
    Ymean = mean(yields$Y_min, na.rm = TRUE)
    
  )
  
  # Return both the summary statistics and the yields dataframe in a list
  return(list(yield_summary = yield_summary, yields = yields))
}

# Generate random T and P values
T <- runif(min = min(clim$tmin_c), max = max(clim$tmin_c),n = 10)
P <- runif(min = min(clim$precip), max = max(clim$precip), n = 10)

# Combine T and P into a dataframe
parms <- data.frame(T = T, P = P)

# Call almond_func for each row of parms
results <- pmap(list(T = parms$T, P = parms$P), almond_func, df = monthly_clim)

results

```


```{r}
library(purrr)

# Define the almond_func function
almond_func <- function(T, P, df) {
  yields <- data.frame()
  
  # iterate over the rows to get yields
  for (date in 1:nrow(df)) {
    
    # Get the temperature and precipitation
    T_min <- T[date]
    if (date > 1) {
      P_val <- P[date - 1]
    } else {
      P_val <- NA  # If there's no previous month, set precipitation to NA
    }
    
    # Calculate yield
    Y_min <- (-0.015 * T_min) - (0.0046 * (T_min^2)) - (0.07 * P_val) + (0.0043 * (P_val^2)) + 0.28
    
    # Get the year and month for the current row
    Year <- df$year[date]
    Month <- df$month[date]
    
    # Create a dataframe with yield, year, and month
    calculations <- data.frame(
      Y_min = Y_min,
      Year = Year,
      Month = Month
    )
    
    # Append the calculations to the yields dataframe
    yields <- rbind(yields, calculations)
  }
  
  # Remove rows with NA values in Y_min
  yields <- na.omit(yields)
  
  # Check if there are any non-missing values in Y_min
  if (nrow(yields) == 0) {
    # If there are no non-missing values, set summary statistics to NA
    yield_summary <- data.frame(
      Ymax = NA,
      Ymin = NA,
      Ymean = NA
    )
  } else {
    # Calculate summary statistics for the yields
    yield_summary <- data.frame(
      Ymax = max(yields$Y_min),
      Ymin = min(yields$Y_min),
      Ymean = mean(yields$Y_min)
    )
  }
  
  # Return both the summary statistics and the yields dataframe in a list
  return(list(yield_summary = yield_summary, yields = yields))
}

# Generate random T and P values
T <- runif(min = min(clim$tmin_c), max = max(clim$tmin_c), n = 9)
P <- runif(min = min(clim$precip), max = max(clim$precip), n = 9)

# Combine T and P into a dataframe
parms <- data.frame(T = T, P = P)

# Call almond_func for each row of parms
results <- pmap(list(T = parms$T, P = parms$P), almond_func, df = monthly_clim)

results
```




```{r}
# FROM DRAFT RMD
T <- runif(min = min(clim$tmin_c),
             max = max(clim$tmin_c),
             n = 9)

P <- runif(min = min(clim$precip),
          max = max(clim$precip),
          n = 9)


parms = cbind.data.frame(T, P)

results <- parms %>% 
  pmap(almond_func,
       df = monthly_clim,
       clr = "skyblue"
       )

results

```

```{r}
#. FROM CLASS
# generate samples for both parameters
nsamples = 300
deviation = 0.15
base_thresh = 10000
ethresh = runif(min=base_thresh-deviation*base_thresh,
                max = base_thresh+deviation*base_thresh, n=nsamples)

eff = rnorm(mean=0.6, sd = 0.1, n=nsamples)

parms = cbind.data.frame(eff, ethresh)

# use pmap 
# takes function name and then names of all parameters that don't change
results = parms %>% pmap(solarpv,  area=0.1, 
                         solar=sierraczosolar, clr="green",
                         eunit="W", g=FALSE, etype="direct")

results[[1]]
length(results)

# now we can extract results from the list as above
mean_elect = map_df(results,`[`, c("mean")) 
# and we can add the parameter values for each run
mean_elect = cbind.data.frame(mean_elect, parms)

# plot - pick on of the 2 parameter as a color

p1 = ggplot(mean_elect, aes(ethresh, mean, col=eff))+geom_point(cex=2)+
  labs(y="Mean Annual Electricity W", x="Threshold Radiation (kJ/m2)  \n above which energy production is more efficient")

p2 = ggplot(mean_elect, aes(eff, mean, col=ethresh))+geom_point(cex=2)+
  labs(y="Mean Annual Electricity W", x="Efficiency")
ggarrange(p1,p2)

# what do we learn from this

# extract annual 
tmp = map_df(results,`[`, c("annual")) 
annual_elect = as.data.frame(tmp$annual$year)
colnames(annual_elect)="year"
annual_elect$elect = tmp$annual$elect
```

### Visual 1
```{r}
# boxplot
ggplot(site2df, 
       aes(as.factor(year),elect, group=year))+
  geom_boxplot()+
  labs(y="Electricity generated in W", x="Year")

```

### Visual 2
```{r}

```

### Visual 3
```{r}

```

